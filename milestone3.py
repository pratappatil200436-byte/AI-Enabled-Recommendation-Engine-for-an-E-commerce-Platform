# -*- coding: utf-8 -*-
"""Milestone3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1DKxj1-pAjwFwhY_YXOdkulJjN_nQ-_HM
"""

from collections import defaultdict

def get_top_n(predictions, n=5):
    top_n = defaultdict(list)

    for uid, iid, true_r, est, _ in predictions:
        top_n[uid].append((iid, est))

    for uid, user_ratings in top_n.items():
        user_ratings.sort(key=lambda x: x[1], reverse=True)
        top_n[uid] = [iid for (iid, _) in user_ratings[:n]]

    return top_n

from collections import defaultdict

def precision_recall_f1_at_k(predictions, k=5, threshold=0.5):

    user_est_true = defaultdict(list)

    for uid, iid, true_r, est, _ in predictions:
        user_est_true[uid].append((est, true_r))

    precisions = {}
    recalls = {}

    for uid, user_ratings in user_est_true.items():

        user_ratings.sort(key=lambda x: x[0], reverse=True)

        top_k = user_ratings[:k]

        relevant = sum((true_r >= threshold) for (_, true_r) in user_ratings)
        recommended = sum((est >= threshold) for (est, _) in top_k)
        relevant_and_recommended = sum(
            ((true_r >= threshold) and (est >= threshold))
            for (est, true_r) in top_k
        )

        precisions[uid] = relevant_and_recommended / recommended if recommended else 0
        recalls[uid] = relevant_and_recommended / relevant if relevant else 0

    precision = sum(precisions.values()) / len(precisions)
    recall = sum(recalls.values()) / len(recalls)

    if precision + recall == 0:
        f1 = 0
    else:
        f1 = 2 * precision * recall / (precision + recall)

    return precision, recall, f1

import pandas as pd
from surprise import Dataset, Reader

data = pd.read_csv("/content/cleaned_ecommerce_dataset.csv")

reader = Reader(rating_scale=(1, int(data['interaction'].max())))

dataset = Dataset.load_from_df(
    data[['user_id','item_id','interaction']],
    reader
)

# The content of this cell has been merged into cell wslIr8WF7bZ4.

from surprise.model_selection import train_test_split

trainset, testset = train_test_split(
    dataset,
    test_size=0.2,
    random_state=42
)

from surprise import SVD

svd_model = SVD(
    n_factors=50,
    n_epochs=20,
    lr_all=0.005,
    reg_all=0.02,
    random_state=42
)

svd_model.fit(trainset)

print("SVD model trained")

# Already done in Milestone 2
predictions = svd_model.test(testset)

precision, recall, f1 = precision_recall_f1_at_k(predictions, k=5)

print("Precision@5:", round(precision,4))
print("Recall@5:", round(recall,4))
print("F1 Score:", round(f1,4))

svd_tuned = SVD(
    n_factors=100,
    n_epochs=30,
    lr_all=0.003,
    reg_all=0.05,
    random_state=42
)

svd_tuned.fit(trainset)

tuned_predictions = svd_tuned.test(testset)

from surprise import accuracy
print("Tuned RMSE:")
accuracy.rmse(tuned_predictions)

p2, r2, f2 = precision_recall_f1_at_k(tuned_predictions, k=5)

print("Tuned Precision:", round(p2,4))
print("Tuned Recall:", round(r2,4))
print("Tuned F1:", round(f2,4))

new_user = data['user_id'].sample(1).iloc[0]

print("Scenario Test User:", new_user)

print(recommend_products_svd(
    svd_tuned,
    data,
    new_user,
    N=5
))

def recommend_products_svd(model, data, user_id, N=5):
    # Get all unique item IDs
    all_items = data['item_id'].unique()

    # Get items the user has already interacted with
    user_interacted_items = data[data['user_id'] == user_id]['item_id'].unique()

    # Filter out items the user has already interacted with
    items_to_predict = [item for item in all_items if item not in user_interacted_items]

    # Predict ratings for the remaining items
    predictions = []
    for item_id in items_to_predict:
        # The 'predict' method returns a Prediction object, we need the estimated rating
        est_rating = model.predict(user_id, item_id).est
        predictions.append((item_id, est_rating))

    # Sort predictions by estimated rating in descending order
    predictions.sort(key=lambda x: x[1], reverse=True)

    # Get the top N recommended items
    top_n_recommendations = [item_id for item_id, _ in predictions[:N]]

    return top_n_recommendations

for n in [3,5,10]:
    recs = recommend_products_svd(svd_tuned, data, new_user, N=n)
    print(f"\nTop {n} recommendations:", recs)